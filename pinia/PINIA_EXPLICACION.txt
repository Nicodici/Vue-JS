================================================================================
                          GUÍA COMPLETA DE PINIA
================================================================================

¿QUÉ ES PINIA?
--------------
Pinia es la biblioteca oficial de gestión de estado para aplicaciones Vue.js.
Es el sucesor de Vuex y está diseñado para trabajar con Vue 3, ofreciendo una
API más simple, intuitiva y con mejor soporte para TypeScript.

Pinia permite centralizar y compartir el estado (datos) entre múltiples 
componentes de tu aplicación de forma reactiva y predecible.

CARACTERÍSTICAS PRINCIPALES:
- Sintaxis simple y directa
- Soporte completo para TypeScript con inferencia automática
- Compatibilidad con Composition API y Options API
- Hot Module Replacement (HMR) en desarrollo
- Plugins para extender funcionalidad
- DevTools integration para debugging
- Modular: cada store es independiente
- Tree-shaking: solo incluye lo que usas


¿POR QUÉ PINIA EN VEZ DE VUEX?
------------------------------
Pinia es el sucesor recomendado de Vuex porque:

✓ MÁS SIMPLE: No hay mutations, solo actions
✓ MENOS BOILERPLATE: Código más limpio y directo
✓ TYPESCRIPT: Inferencia automática sin configuración manual
✓ MODULAR: No necesitas módulos anidados complejos
✓ COMPOSITION API: Diseñado para trabajar con Composition API
✓ OFICIAL: Es la solución oficialmente recomendada por el equipo de Vue


¿PARA QUÉ SIRVE PINIA?
-----------------------
Pinia es útil cuando necesitas:

• Compartir estado entre múltiples componentes no relacionados
• Centralizar la lógica de negocio de tu aplicación
• Mantener datos que persisten durante la navegación
• Gestionar datos de usuario autenticado
• Cache de datos de APIs
• Gestionar estado complejo con múltiples propiedades relacionadas
• Debugging avanzado con DevTools
• Server-Side Rendering (SSR) con estado hidratado


INSTALACIÓN
-----------
# Con npm
npm install pinia

# Con yarn
yarn add pinia

# Con pnpm
pnpm add pinia


CONFIGURACIÓN BÁSICA
---------------------
En main.js:

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')


CREAR UN STORE
--------------
Los stores en Pinia se pueden crear de dos formas principales:

OPCIÓN 1: Setup Stores (Composition API) - RECOMENDADO
-------------------------------------------------------
Sintaxis similar a Composition API con setup():

// stores/counter.js
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', () => {
  // State (datos reactivos)
  const count = ref(0)
  const name = ref('Eduardo')

  // Getters (computados)
  const doubleCount = computed(() => count.value * 2)

  // Actions (funciones)
  function increment() {
    count.value++
  }

  function decrement() {
    count.value--
  }

  async function fetchData() {
    const response = await fetch('https://api.example.com/data')
    const data = await response.json()
    count.value = data.count
  }

  // Retornar todo lo que quieres exponer
  return { 
    count, 
    name, 
    doubleCount, 
    increment, 
    decrement,
    fetchData 
  }
})


OPCIÓN 2: Option Stores (Options API)
--------------------------------------
Sintaxis similar a Options API:

// stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  // State
  state: () => ({
    count: 0,
    name: 'Eduardo'
  }),

  // Getters (como computed)
  getters: {
    doubleCount: (state) => state.count * 2,
    
    // Con acceso a otros getters
    quadrupleCount() {
      return this.doubleCount * 2
    }
  },

  // Actions (como methods)
  actions: {
    increment() {
      this.count++
    },

    decrement() {
      this.count--
    },

    async fetchData() {
      const response = await fetch('https://api.example.com/data')
      const data = await response.json()
      this.count = data.count
    }
  }
})


USAR UN STORE EN COMPONENTES
-----------------------------

COMPOSITION API (con <script setup>)
-------------------------------------
<script setup>
import { useCounterStore } from '@/stores/counter'

// Opción 1: Usar el store directamente
const counterStore = useCounterStore()

// Acceder al estado
counterStore.count // 0

// Acceder a getters
counterStore.doubleCount // 0

// Llamar actions
counterStore.increment()

// Opción 2: Desestructurar (⚠️ PIERDE REACTIVIDAD)
const { count, name } = counterStore // ❌ No reactivo

// Opción 3: Usar storeToRefs para mantener reactividad ✅
import { storeToRefs } from 'pinia'
const { count, name, doubleCount } = storeToRefs(counterStore) // ✅ Reactivo

// Las actions se pueden desestructurar directamente (no pierden reactividad)
const { increment, decrement } = counterStore // ✅ OK
</script>

<template>
  <div>
    <!-- Usando store directamente -->
    <p>Count: {{ counterStore.count }}</p>
    <p>Double: {{ counterStore.doubleCount }}</p>
    <button @click="counterStore.increment">Incrementar</button>

    <!-- Usando variables desestructuradas con storeToRefs -->
    <p>Count: {{ count }}</p>
    <p>Double: {{ doubleCount }}</p>
    <button @click="increment">Incrementar</button>
  </div>
</template>


OPTIONS API
-----------
<script>
import { useCounterStore } from '@/stores/counter'

export default {
  setup() {
    const counterStore = useCounterStore()
    return { counterStore }
  },
  
  computed: {
    count() {
      return this.counterStore.count
    }
  },
  
  methods: {
    increment() {
      this.counterStore.increment()
    }
  }
}
</script>


CONCEPTOS CLAVE
---------------

1. STATE (Estado)
   - Datos reactivos del store
   - Se define como función que retorna un objeto (Options API)
   - O con ref/reactive (Composition API)

2. GETTERS (Computados)
   - Valores derivados del estado
   - Se cachean automáticamente
   - Equivalente a computed properties
   - Pueden acceder a otros getters

3. ACTIONS (Acciones)
   - Métodos que modifican el estado
   - Pueden ser síncronas o asíncronas
   - Equivalente a methods
   - Pueden llamar a otras actions

4. storeToRefs()
   - Función helper para desestructurar manteniendo reactividad
   - Solo para state y getters, NO para actions
   - Uso: const { state1, state2 } = storeToRefs(store)


MODIFICAR EL ESTADO
-------------------

1. Directamente (solo en actions):
   store.count++

2. Con $patch (múltiples cambios):
   store.$patch({
     count: store.count + 1,
     name: 'Nuevo nombre'
   })

3. Con $patch function (lógica compleja):
   store.$patch((state) => {
     state.items.push({ name: 'shoes', quantity: 1 })
     state.hasChanged = true
   })

4. Reemplazar todo el estado (raramente usado):
   store.$state = { count: 24, name: 'Eduardo' }

5. Resetear al estado inicial:
   store.$reset()


MÚLTIPLES STORES
----------------
Puedes crear múltiples stores independientes:

// stores/user.js
export const useUserStore = defineStore('user', () => {
  const name = ref('')
  const email = ref('')
  const isAuthenticated = ref(false)

  function login(username, password) {
    // lógica de login
    isAuthenticated.value = true
  }

  function logout() {
    name.value = ''
    email.value = ''
    isAuthenticated.value = false
  }

  return { name, email, isAuthenticated, login, logout }
})

// stores/cart.js
export const useCartStore = defineStore('cart', () => {
  const items = ref([])
  
  const totalPrice = computed(() => {
    return items.value.reduce((total, item) => {
      return total + item.price * item.quantity
    }, 0)
  })

  function addItem(product) {
    items.value.push(product)
  }

  function removeItem(productId) {
    const index = items.value.findIndex(item => item.id === productId)
    if (index > -1) items.value.splice(index, 1)
  }

  return { items, totalPrice, addItem, removeItem }
})


USAR MÚLTIPLES STORES EN UN COMPONENTE
---------------------------------------
<script setup>
import { useUserStore } from '@/stores/user'
import { useCartStore } from '@/stores/cart'

const userStore = useUserStore()
const cartStore = useCartStore()
</script>

<template>
  <div>
    <p>Usuario: {{ userStore.name }}</p>
    <p>Items en carrito: {{ cartStore.items.length }}</p>
    <p>Total: ${{ cartStore.totalPrice }}</p>
  </div>
</template>


ACCEDER A OTROS STORES DESDE UN STORE
--------------------------------------
import { defineStore } from 'pinia'
import { useUserStore } from './user'

export const useCartStore = defineStore('cart', () => {
  const items = ref([])

  function checkout() {
    const userStore = useUserStore()
    
    if (!userStore.isAuthenticated) {
      alert('Debes iniciar sesión')
      return
    }
    
    // procesar compra...
  }

  return { items, checkout }
})


PERSISTENCIA (LocalStorage)
----------------------------
Para persistir el estado, puedes usar el plugin pinia-plugin-persistedstate:

# Instalar
npm install pinia-plugin-persistedstate

// main.js
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

// Usar en store
export const useUserStore = defineStore('user', {
  state: () => ({
    name: '',
    token: ''
  }),
  
  persist: true // Guarda automáticamente en localStorage
})

// O con configuración personalizada
persist: {
  key: 'my-custom-key',
  storage: sessionStorage,
  paths: ['name'] // Solo persiste name, no token
}


DEVTOOLS
--------
Pinia se integra automáticamente con Vue DevTools:

- Ver todos los stores y su estado actual
- Historial de cambios (time-travel debugging)
- Editar estado directamente desde DevTools
- Inspeccionar getters y sus valores


TESTING
-------
Los stores de Pinia son fáciles de testear:

import { setActivePinia, createPinia } from 'pinia'
import { useCounterStore } from '@/stores/counter'

describe('Counter Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('increments', () => {
    const counter = useCounterStore()
    expect(counter.count).toBe(0)
    counter.increment()
    expect(counter.count).toBe(1)
  })

  it('doubles the count', () => {
    const counter = useCounterStore()
    counter.count = 5
    expect(counter.doubleCount).toBe(10)
  })
})


MEJORES PRÁCTICAS
-----------------
1. Usa Setup Stores (Composition API) para proyectos nuevos
2. Nombra los stores con el prefijo "use": useUserStore, useCartStore
3. Un store por dominio/funcionalidad, no uno gigante
4. Usa storeToRefs() al desestructurar state/getters
5. Las actions NO necesitan storeToRefs, puedes desestructurarlas directamente
6. Mantén la lógica de negocio en actions, no en componentes
7. Usa getters para valores derivados en lugar de calcularlos en componentes
8. Para actualizaciones múltiples, usa $patch en lugar de múltiples asignaciones
9. No mutes el estado fuera de actions (mala práctica)
10. Usa TypeScript para mejor autocompletado y detección de errores


COMPARACIÓN SETUP STORE VS OPTION STORE
----------------------------------------
Setup Store (Composition API):
✓ Más flexible
✓ Mejor composición con composables
✓ Más cercano a Composition API de Vue
✓ Recomendado para proyectos nuevos

Option Store (Options API):
✓ Más familiar para usuarios de Vuex
✓ Estructura más definida
✓ Separación clara de state, getters, actions


EJEMPLO COMPLETO: TODO APP
---------------------------
// stores/todos.js
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useTodosStore = defineStore('todos', () => {
  // State
  const todos = ref([])
  const filter = ref('all') // 'all', 'active', 'completed'

  // Getters
  const filteredTodos = computed(() => {
    if (filter.value === 'active') {
      return todos.value.filter(todo => !todo.completed)
    }
    if (filter.value === 'completed') {
      return todos.value.filter(todo => todo.completed)
    }
    return todos.value
  })

  const activeTodosCount = computed(() => {
    return todos.value.filter(todo => !todo.completed).length
  })

  const completedTodosCount = computed(() => {
    return todos.value.filter(todo => todo.completed).length
  })

  // Actions
  function addTodo(text) {
    todos.value.push({
      id: Date.now(),
      text,
      completed: false
    })
  }

  function removeTodo(id) {
    const index = todos.value.findIndex(todo => todo.id === id)
    if (index > -1) {
      todos.value.splice(index, 1)
    }
  }

  function toggleTodo(id) {
    const todo = todos.value.find(todo => todo.id === id)
    if (todo) {
      todo.completed = !todo.completed
    }
  }

  function setFilter(newFilter) {
    filter.value = newFilter
  }

  function clearCompleted() {
    todos.value = todos.value.filter(todo => !todo.completed)
  }

  return {
    todos,
    filter,
    filteredTodos,
    activeTodosCount,
    completedTodosCount,
    addTodo,
    removeTodo,
    toggleTodo,
    setFilter,
    clearCompleted
  }
})


ERRORES COMUNES
---------------
1. ❌ Desestructurar sin storeToRefs (pierde reactividad)
   const { count } = counterStore // ❌ No reactivo
   
   ✅ Usar storeToRefs
   const { count } = storeToRefs(counterStore) // ✅ Reactivo

2. ❌ Modificar estado fuera de actions (en Option Store)
   // En componente
   counterStore.count++ // ❌ Mala práctica
   
   ✅ Usar actions
   counterStore.increment() // ✅ Correcto

3. ❌ Usar storeToRefs en actions
   const { increment } = storeToRefs(counterStore) // ❌ Innecesario
   
   ✅ Desestructurar directamente
   const { increment } = counterStore // ✅ Correcto

4. ❌ No usar await en actions asíncronas
   async function fetchData() {
     fetch('/api/data') // ❌ No espera
   }
   
   ✅ Usar await
   async function fetchData() {
     const response = await fetch('/api/data') // ✅ Correcto
     const data = await response.json()
     return data
   }


RECURSOS
--------
- Documentación oficial: https://pinia.vuejs.org
- GitHub: https://github.com/vuejs/pinia
- Discord Vue.js: https://discord.com/invite/vue
- Ejemplos: https://github.com/piniajs/example-vue-3-vite


MIGRACIÓN DESDE VUEX
---------------------
Cambios principales:
- mutations → eliminadas (usar actions directamente)
- modules → cada módulo es un store separado
- namespaced → no necesario, cada store es independiente
- mapState/mapGetters → storeToRefs()
- mapActions → desestructuración directa
- state → función que retorna objeto
- commit → directamente modifica en actions


CONCLUSIÓN
----------
Pinia es la solución moderna y recomendada para gestión de estado en Vue 3.
Su API simple, excelente soporte TypeScript y flexibilidad lo hacen ideal
para proyectos de cualquier tamaño.

Con Pinia obtienes:
- Código más limpio y mantenible
- Mejor developer experience
- Excelente integración con Vue 3
- Rendimiento optimizado

Es la evolución natural de Vuex y la opción oficial del equipo de Vue.

================================================================================
